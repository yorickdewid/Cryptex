// Copyright (c) 2017 Quenza Inc. All rights reserved.
//
// This file is part of the Cryptox project.
//
// Use of this source code is governed by a private license
// that can be found in the LICENSE file. Content can not be 
// copied and/or distributed without the express of the author.

#include <Cry/Cry.h>
#include <Cry/Config.h>

#include <boost/format.hpp>
#include <boost/property_tree/ptree.hpp>
#include <boost/property_tree/xml_parser.hpp>

#include <map>
#include <string>
#include <fstream>
#include <iostream>
#include <stdexcept>

#define DEFUALT_VERSION 3
#define DEFAULT_NAMESPACE ""

// Template for generated header. Edit the source below to update
// the generated header.
static const std::string resultingSource =
R"(// Copyright (c) 2017 Quenza Inc. All rights reserved.
//
// This file is part of the Cryptox project.
//
// Use of this source code is governed by a private license
// that can be found in the LICENSE file. Content can not be 
// copied and/or distributed without the express of the author.

//TODO:
// - Aliasing
// - Namespacing

#pragma once

#include <iostream>
#include <cstdio>
#include <array>
#include <string>

// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //
// AUTOGENERATED SOURCE, DO NOT EDIT MANUALLY. RUN THE MESSAGE
// GENERATOR TO UPDATE THE EVENT LOGGER.
//
// Manifest version : %d
// Event items      : %d
// Manifest         : %s
// Generated        : %s
//
// !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! //

#define _EV_MIN_ITEM_ID %d
#define _EV_MAX_ITEM_ID %d

// Log output facility.
static std::ostream& g_outputStream = std::cout;

// List of aliases matching the error code. The alias is optional
// and is generated by the message generator.
enum struct AliasErrorCode
{
	//TODO
};

struct EventLevel
{
	enum Level
	{%s
	};

	// Get shortcode from level.
	static char GetCharCode(Level level) noexcept
	{
		switch (level)
		{%s
		}

		return '\0';
	}
};

struct EventItem final
{
	EventLevel::Level level{ EventLevel::%s };
	const int errorCode;
	const std::string title;
	const std::string desc;

public:
	EventItem(int code, const std::string& title)
		: errorCode{ code }
		, title{ title }
	{
	}
	EventItem(int code, const std::string& title, const std::string& desc)
		: errorCode{ code }
		, title{ title }
		, desc{ desc }
	{
	}
	EventItem(int code, EventLevel::Level level, const std::string& title)
		: level{ level }
		, errorCode{ code }
		, title{ title }
	{
	}
	EventItem(int code, EventLevel::Level level, const std::string& title, const std::string& desc)
		: level{ level }
		, errorCode{ code }
		, title{ title }
		, desc{ desc }
	{
	}

	std::string InfoLine() const
	{
		char code[8];
		sprintf_s(code, sizeof(code), "%%c%%d: ", EventLevel::GetCharCode(level), errorCode);
		return std::string{ code } + title;
	}
};

// List of events generated by the message generator.
static const std::array<EventItem, %d> g_eventItemList = std::array<EventItem, %d>
{%s
};

namespace EventLog
{

namespace Detail
{

struct MatchEvent final
{
	int m_code;

	inline MatchEvent(int code)
		: m_code{ code }
	{
	}

	inline bool operator()(const EventItem& event) const
	{
		return m_code == event.errorCode;
	}
};

// Retrieve event by error code.
const EventItem& FetchEvent(int code)
{
	MatchEvent matcher{ code };
	if (code < _EV_MIN_ITEM_ID || code > _EV_MAX_ITEM_ID) {
		throw 1; //TODO: throw something usefull
	}
	const auto result = std::find_if(g_eventItemList.cbegin(), g_eventItemList.cend(), matcher);
	if (result == g_eventItemList.cend()) {
		throw 1; //TODO: throw something usefull
	}
	return (*result);
}

} // namespace Detail

struct FatalException : public std::exception
{
	std::string m_msg;
	const EventItem& m_eventLink;

	// FUTURE: no static buffer size.
	std::string PostProcess(const char *fmt, ...)
	{
		char obuffer[2048];
		va_list args;
		va_start(args, fmt);
		vsprintf_s(obuffer, sizeof(obuffer), fmt, args);
		va_end(args);
		return obuffer;
	}

public:
	// Create an exception with an error code.
	template<typename... Params>
	FatalException(int code, Params&&... params)
		: m_eventLink{ Detail::FetchEvent(code) }
	{
		m_msg = PostProcess(m_eventLink.InfoLine().c_str(), std::forward<Params>(params)...);
	}

	// Create an exception with an alias.
	template<typename... Params>
	explicit FatalException(AliasErrorCode code, Params&&... params)
		: m_eventLink{ Detail::FetchEvent(static_cast<int>(code)) }
	{
		m_msg = PostProcess(m_eventLink.InfoLine().c_str(), std::forward<Params>(params)...);
	}

	// Get the event from the exception.
	inline const EventItem& Event() const noexcept
	{
		return m_eventLink;
	}

	// Access the exception messga via the std::exception interface.
	virtual char const *what() const
	{
		return m_msg.c_str();
	}
};

// Create new exception event.
template<typename... ArgsType>
FatalException MakeException(ArgsType&&... args)
{
	return FatalException{ std::forward<ArgsType>(args)... };
}

// Log message to output stream.
inline void Log(EventLevel::Level level, const std::string& msg)
{
	g_outputStream << EventItem{ 9999, level, msg }.InfoLine() << std::endl;
}

// Log exception to output stream.
inline void Log(const FatalException& ev)
{
	g_outputStream << ev.Event().InfoLine() << std::endl;
}

// Get the number of registered events in the static array.
inline size_t EventItemCount() noexcept { return %d; }
// Check if fatal exception has description.
inline bool HasDescription(const FatalException& ev) { return !ev.Event().desc.empty(); }
// Get the event message info line from an fatal exception.
inline std::string GetInfoLine(const FatalException& ev) { return ev.Event().InfoLine(); }
// Get the title from an fatal exception.
inline std::string GetTitle(const FatalException& ev) { return ev.Event().title; }
// Get the description from an fatal exception, if any.
inline std::string GetDescription(const FatalException& ev) { return ev.Event().desc; }

} // namespace EventLog

)";

static void AssertVersion(int version)
{
	if (version != DEFUALT_VERSION) {
		throw std::runtime_error{ "invalid manifest version" };
	}
}

static std::string DateTime()
{
	struct tm tm;
	CRY_LOCALTIME(&tm);

	std::ostringstream oss;
	oss << std::put_time(&tm, "%d-%m-%Y %H:%M:%S");
	return oss.str();
}

struct Manifest final
{
	struct Level
	{
		char shortHand;
		const std::string name;
	};

	struct Event
	{
		const Level& level;
		const std::string title;
		const std::string description;
	};

	std::map<int, Level> m_levels;
	std::map<int, Event> m_events;

	std::string inputfile;
	std::string namespacing;

	Manifest() = default;
	Manifest(const std::string& inputfile)
		: inputfile{ inputfile }
	{
	}

	// Load the manifest file.
	void Load();

	// Dump the events into the resulting source.
	void Dump(const std::string&);

private:
	int MinimumId();
	int MaximumId();
	std::string EventLevelLevelStub();
	std::string EventLevelGetCharCodeStub();
	std::string EventLevelDefaultValue();
	std::string ItemListStub();
};

int Manifest::MinimumId()
{
	return std::max_element(m_events.begin(), m_events.end(), [](const auto &lhs, const auto &rhs) -> bool
	{
		return (lhs.first > rhs.first);
	})->first;
}

int Manifest::MaximumId()
{
	return std::max_element(m_events.begin(), m_events.end(), [](const auto &lhs, const auto &rhs) -> bool
	{
		return (lhs.first < rhs.first);
	})->first;
}

std::string Manifest::EventLevelLevelStub()
{
	std::string out;
	for (const auto& level : m_levels) {
		out += "\n\t\t" + level.second.name + " = " + std::to_string(level.first) + ",";
	}
	return out;
}

std::string Manifest::EventLevelGetCharCodeStub()
{
	std::string out;
	for (const auto& level : m_levels) {
		out += "\n\t\tcase " + level.second.name + ": return '" + level.second.shortHand + "';";
	}
	return out;
}

std::string Manifest::EventLevelDefaultValue()
{
	return m_levels.begin()->second.name;
}

std::string Manifest::ItemListStub()
{
	std::string out;
	for (const auto& event : m_events) {
		if (event.second.description.empty()) {
			out += "\n\tEventItem{ " + std::to_string(event.first) + ", EventLevel::" + event.second.level.name + ", \"" + event.second.title + "\" },";
		}
		else {
			out += "\n\tEventItem{ " + std::to_string(event.first) + ", EventLevel::" + event.second.level.name + ", \"" + event.second.title + "\", \"" + event.second.description + "\" },";
		}
	}
	return out;
}

void Manifest::Load()
{
	using namespace boost::property_tree;

	// Create empty property tree object.
	ptree tree;

	// Parse the XML into the property tree.
	read_xml(inputfile, tree);

	// Assert manifest version.
	AssertVersion(tree.get<int>("manifest.<xmlattr>.version"));

	// Register the levels in the object.
	for (const auto& element : tree.get_child("manifest.levels")) {
		int id = element.second.get<int>("<xmlattr>.id");
		char code = element.second.get<char>("<xmlattr>.code");
		const std::string name = element.second.data();
		m_levels.emplace(std::pair<int, Manifest::Level>(id, { code, name }));
	}

	// Register events and match the levels.
	for (const auto& element : tree.get_child("manifest.events")) {
		int id = element.second.get<int>("<xmlattr>.id");
		int resolveLevel = element.second.get<int>("level");
		const std::string title = element.second.get<std::string>("title");
		if (m_levels.find(resolveLevel) == m_levels.end()) {
			throw std::runtime_error{ "referece level not found" };
		}
		const auto& levelObject = m_levels[resolveLevel];
		m_events.emplace(std::pair<int, Manifest::Event>(id, { levelObject, title }));
	}

	if (m_levels.empty()) {
		throw std::runtime_error{ "Specify at least one level" };
	}
	if (m_events.empty()) {
		throw std::runtime_error{ "Specify at least one event" };
	}
}

void Manifest::Dump(const std::string& outFile)
{
	std::ofstream sourceFile;
	sourceFile.open(outFile);
	sourceFile << boost::format{ resultingSource }
		% DEFUALT_VERSION
		% m_events.size()
		% inputfile
		% DateTime()
		% MinimumId()
		% MaximumId()
		% EventLevelLevelStub()
		% EventLevelGetCharCodeStub()
		% EventLevelDefaultValue()
		% m_events.size()
		% m_events.size()
		% ItemListStub()
		% m_events.size();
	sourceFile.close();
}

void usage(const char *progname)
{
	std::cerr << PROGRAM_UTIL_HEADER << std::endl << std::endl;
	std::cerr << progname << ": [MANIFEST] [OUTFILE]" << std::endl;
	std::cerr << "\nOptions:" << std::endl;
	std::cerr << "  -n,--namespace          Optional namespace" << std::endl;
}

int main(int argc, char *argv[])
{
	if (argc < 3) {
		usage(argv[0]);
		return 1;
	}

	Manifest manifest{ argv[1] };
	std::string outputfile{ argv[2] };

	if (argc > 2) {
		const auto command = std::string{ argv[1] };
		if (command == "/n" || command == "-n" || command == "--namespace") {
			if (argc < 5) {
				usage(argv[0]);
				return 1;
			}
			manifest.namespacing = argv[2];
			manifest.inputfile = argv[3];
			outputfile = argv[4];
		}
	}

	try {
		manifest.Load();
		manifest.Dump(outputfile);
	}
	catch (const std::exception& e) {
		std::cerr << e.what() << std::endl;
		return 1;
	}

	return 0;
}
